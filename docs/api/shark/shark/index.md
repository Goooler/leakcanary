//[shark](../../index.md)/[shark](index.md)

# Package shark

## Types

| Name | Summary |
|---|---|
| [ApplicationLeak](-application-leak/index.md) | [jvm]<br>data class [ApplicationLeak](-application-leak/index.md)(leakTraces: [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[LeakTrace](-leak-trace/index.md)&gt;) : [Leak](-leak/index.md)<br>A leak found by [HeapAnalyzer](-heap-analyzer/index.md) in your application. |
| [AppSingletonInspector](-app-singleton-inspector/index.md) | [jvm]<br>class [AppSingletonInspector](-app-singleton-inspector/index.md)(singletonClasses: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)) : [ObjectInspector](-object-inspector/index.md)<br>Inspector that automatically marks instances of the provided class names as not leaking because they're app wide singletons. |
| [FilteringLeakingObjectFinder](-filtering-leaking-object-finder/index.md) | [jvm]<br>class [FilteringLeakingObjectFinder](-filtering-leaking-object-finder/index.md)(filters: [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[FilteringLeakingObjectFinder.LeakingObjectFilter](-filtering-leaking-object-finder/-leaking-object-filter/index.md)&gt;) : [LeakingObjectFinder](-leaking-object-finder/index.md)<br>Finds the objects that are leaking by scanning all objects in the heap dump and delegating the decision to a list of [FilteringLeakingObjectFinder.LeakingObjectFilter](-filtering-leaking-object-finder/-leaking-object-filter/index.md) |
| [HeapAnalysis](-heap-analysis/index.md) | [jvm]<br>sealed class [HeapAnalysis](-heap-analysis/index.md) : [Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)<br>The result of an analysis performed by [HeapAnalyzer](-heap-analyzer/index.md), either a [HeapAnalysisSuccess](-heap-analysis-success/index.md) or a [HeapAnalysisFailure](-heap-analysis-failure/index.md). This class is serializable however there are no guarantees of forward compatibility. |
| [HeapAnalysisException](-heap-analysis-exception/index.md) | [jvm]<br>class [HeapAnalysisException](-heap-analysis-exception/index.md)(cause: [Throwable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)) : [RuntimeException](https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html) |
| [HeapAnalysisFailure](-heap-analysis-failure/index.md) | [jvm]<br>data class [HeapAnalysisFailure](-heap-analysis-failure/index.md)(heapDumpFile: [File](https://docs.oracle.com/javase/8/docs/api/java/io/File.html), createdAtTimeMillis: [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html), dumpDurationMillis: [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html), analysisDurationMillis: [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html), exception: [HeapAnalysisException](-heap-analysis-exception/index.md)) : [HeapAnalysis](-heap-analysis/index.md)<br>The analysis performed by [HeapAnalyzer](-heap-analyzer/index.md) did not complete successfully. |
| [HeapAnalysisSuccess](-heap-analysis-success/index.md) | [jvm]<br>data class [HeapAnalysisSuccess](-heap-analysis-success/index.md)(heapDumpFile: [File](https://docs.oracle.com/javase/8/docs/api/java/io/File.html), createdAtTimeMillis: [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html), dumpDurationMillis: [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html), analysisDurationMillis: [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html), metadata: [Map](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)&lt;[String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html), [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)&gt;, applicationLeaks: [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[ApplicationLeak](-application-leak/index.md)&gt;, libraryLeaks: [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[LibraryLeak](-library-leak/index.md)&gt;, unreachableObjects: [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[LeakTraceObject](-leak-trace-object/index.md)&gt;) : [HeapAnalysis](-heap-analysis/index.md)<br>The result of a successful heap analysis performed by [HeapAnalyzer](-heap-analyzer/index.md). |
| [HeapAnalyzer](-heap-analyzer/index.md) | [jvm]<br>class [HeapAnalyzer](-heap-analyzer/index.md)(listener: [OnAnalysisProgressListener](-on-analysis-progress-listener/index.md))<br>Analyzes heap dumps to look for leaks. |
| [IgnoredReferenceMatcher](-ignored-reference-matcher/index.md) | [jvm]<br>class [IgnoredReferenceMatcher](-ignored-reference-matcher/index.md)(pattern: [ReferencePattern](-reference-pattern/index.md)) : [ReferenceMatcher](-reference-matcher/index.md)<br>[IgnoredReferenceMatcher](-ignored-reference-matcher/index.md) should be used to match references that cannot ever create leaks. The shortest path finder will never go through matching references. |
| [KeyedWeakReferenceFinder](-keyed-weak-reference-finder/index.md) | [jvm]<br>object [KeyedWeakReferenceFinder](-keyed-weak-reference-finder/index.md) : [LeakingObjectFinder](-leaking-object-finder/index.md)<br>Finds all objects tracked by a KeyedWeakReference, ie all objects that were passed to ObjectWatcher.watch. |
| [Leak](-leak/index.md) | [jvm]<br>sealed class [Leak](-leak/index.md) : [Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)<br>A leak found by [HeapAnalyzer](-heap-analyzer/index.md), either an [ApplicationLeak](-application-leak/index.md) or a [LibraryLeak](-library-leak/index.md). |
| [LeakingObjectFinder](-leaking-object-finder/index.md) | [jvm]<br>fun interface [LeakingObjectFinder](-leaking-object-finder/index.md)<br>Finds the objects that are leaking, for which Shark will compute leak traces. |
| [LeakTrace](-leak-trace/index.md) | [jvm]<br>data class [LeakTrace](-leak-trace/index.md)(gcRootType: [LeakTrace.GcRootType](-leak-trace/-gc-root-type/index.md), referencePath: [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[LeakTraceReference](-leak-trace-reference/index.md)&gt;, leakingObject: [LeakTraceObject](-leak-trace-object/index.md)) : [Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)<br>The best strong reference path from a GC root to the leaking object. "Best" here means the shortest prioritized path. A large number of distinct paths can generally be found leading to a leaking object. Shark prioritizes paths that don't go through known [LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md) (because those are known to create leaks so it's more interesting to find other paths causing leaks), then it prioritize paths that don't go through java local gc roots (because those are harder to reason about). Taking those priorities into account, finding the shortest path means there are less [LeakTraceReference](-leak-trace-reference/index.md) that can be suspected to cause the leak. |
| [LeakTraceObject](-leak-trace-object/index.md) | [jvm]<br>data class [LeakTraceObject](-leak-trace-object/index.md)(type: [LeakTraceObject.ObjectType](-leak-trace-object/-object-type/index.md), className: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html), labels: [Set](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)&lt;[String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)&gt;, leakingStatus: [LeakTraceObject.LeakingStatus](-leak-trace-object/-leaking-status/index.md), leakingStatusReason: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html), retainedHeapByteSize: [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?, retainedObjectCount: [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?) : [Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html) |
| [LeakTraceReference](-leak-trace-reference/index.md) | [jvm]<br>data class [LeakTraceReference](-leak-trace-reference/index.md)(originObject: [LeakTraceObject](-leak-trace-object/index.md), referenceType: [LeakTraceReference.ReferenceType](-leak-trace-reference/-reference-type/index.md), owningClassName: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html), referenceName: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)) : [Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)<br>A [LeakTraceReference](-leak-trace-reference/index.md) represents an origin [LeakTraceObject](-leak-trace-object/index.md) and either a reference from that object to the [LeakTraceObject](-leak-trace-object/index.md) in the next [LeakTraceReference](-leak-trace-reference/index.md) in [LeakTrace.referencePath](-leak-trace/reference-path.md), or to [LeakTrace.leakingObject](-leak-trace/leaking-object.md) if this is the last [LeakTraceReference](-leak-trace-reference/index.md) in [LeakTrace.referencePath](-leak-trace/reference-path.md). |
| [LibraryLeak](-library-leak/index.md) | [jvm]<br>data class [LibraryLeak](-library-leak/index.md)(leakTraces: [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[LeakTrace](-leak-trace/index.md)&gt;, pattern: [ReferencePattern](-reference-pattern/index.md), description: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)) : [Leak](-leak/index.md)<br>A leak found by [HeapAnalyzer](-heap-analyzer/index.md), where the only path to the leaking object required going through a reference matched by [pattern](-library-leak/pattern.md), as provided to a [LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md) instance. This is a known leak in library code that is beyond your control. |
| [LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md) | [jvm]<br>data class [LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md)(pattern: [ReferencePattern](-reference-pattern/index.md), description: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html), patternApplies: (HeapGraph) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)) : [ReferenceMatcher](-reference-matcher/index.md)<br>[LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md) should be used to match references in library code that are known to create leaks and are beyond your control. The shortest path finder will only go through matching references after it has exhausted references that don't match, prioritizing finding an application leak over a known library leak. Library leaks will be reported as [LibraryLeak](-library-leak/index.md) instead of [ApplicationLeak](-application-leak/index.md). |
| [MetadataExtractor](-metadata-extractor/index.md) | [jvm]<br>fun interface [MetadataExtractor](-metadata-extractor/index.md)<br>Extracts metadata from a hprof to be reported in [HeapAnalysisSuccess.metadata](-heap-analysis-success/metadata.md). |
| [ObjectInspector](-object-inspector/index.md) | [jvm]<br>fun interface [ObjectInspector](-object-inspector/index.md)<br>Provides LeakCanary with insights about objects (classes, instances and arrays) found in the heap. [inspect](-object-inspector/inspect.md) will be called for each object that LeakCanary wants to know more about. The implementation can then use the provided [ObjectReporter](-object-reporter/index.md) to provide insights for that object. |
| [ObjectInspectors](-object-inspectors/index.md) | [jvm]<br>enum [ObjectInspectors](-object-inspectors/index.md) : [Enum](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-enum/index.html)&lt;[ObjectInspectors](-object-inspectors/index.md)&gt; , [ObjectInspector](-object-inspector/index.md)<br>A set of default [ObjectInspector](-object-inspector/index.md)s that knows about common JDK objects. |
| [ObjectReporter](-object-reporter/index.md) | [jvm]<br>class [ObjectReporter](-object-reporter/index.md)(heapObject: HeapObject)<br>Enables [ObjectInspector](-object-inspector/index.md) implementations to provide insights on [heapObject](-object-reporter/heap-object.md), which is an object (class, instance or array) found in the heap. |
| [OnAnalysisProgressListener](-on-analysis-progress-listener/index.md) | [jvm]<br>fun interface [OnAnalysisProgressListener](-on-analysis-progress-listener/index.md)<br>Reports progress from the [HeapAnalyzer](-heap-analyzer/index.md) as they occur, as [Step](-on-analysis-progress-listener/-step/index.md) values. |
| [ReferenceMatcher](-reference-matcher/index.md) | [jvm]<br>sealed class [ReferenceMatcher](-reference-matcher/index.md)<br>Used to pattern match known patterns of references in the heap, either to ignore them ([IgnoredReferenceMatcher](-ignored-reference-matcher/index.md)) or to mark them as library leaks ([LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md)). |
| [ReferencePattern](-reference-pattern/index.md) | [jvm]<br>sealed class [ReferencePattern](-reference-pattern/index.md) : [Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)<br>A pattern that will match references for a given [ReferenceMatcher](-reference-matcher/index.md). |
